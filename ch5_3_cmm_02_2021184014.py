questions = [
  [7, 4, 11, 11, 6, 3, 4, 11, 14, 20],
  [5, 17, 17, 8, 14, 6, 20, 17, 4, 18],
  [20, 11, 9, 15, 7, 9, 9, 10, 6, 9],
  [17, 19, 15, 7, 11, 6, 8, 5, 4, 9],
  [15, 13, 19, 13, 4, 16, 17, 14, 16, 12],
  [5, 9, 20, 10, 13, 17, 9, 12, 17, 5],
]

# 출력은 다음과 같은 형태로 한다.
# sizes=[7, 4, 11, 11, 6, 3, 4, 11, 14, 20]
# 2631 (((7x4) x ((4x11) x ((11x11) x ((11x6) x (6x3))))) x ((((3x4) x (4x11)) x (11x14)) x (14x20)))
# sizes=[5, 17, 17, 8, 14, 6, 20, 17, 4, 18]
# 5024 (((5x17) x ((17x17) x ((17x8) x ((8x14) x ((14x6) x ((6x20) x ((20x17) x (17x4)))))))) x (4x18))
# sizes=[20, 11, 9, 15, 7, 9, 9, 10, 6, 9]
# 5721 (((20x11) x ((11x9) x (((9x15) x (15x7)) x ((7x9) x ((9x9) x ((9x10) x (10x6))))))) x (6x9))
# sizes=[17, 19, 15, 7, 11, 6, 8, 5, 4, 9]
# 4388 (((17x19) x ((19x15) x ((15x7) x ((7x11) x ((11x6) x ((6x8) x ((8x5) x (5x4)))))))) x (4x9))
# sizes=[15, 13, 19, 13, 4, 16, 17, 14, 16, 12]
# 7180 (((15x13) x ((13x19) x ((19x13) x (13x4)))) x (((((4x16) x (16x17)) x (17x14)) x (14x16)) x (16x12)))
# sizes=[5, 9, 20, 10, 13, 17, 9, 12, 17, 5]
# 6205 ((5x9) x ((9x20) x ((20x10) x ((10x13) x ((13x17) x ((17x9) x ((9x12) x ((12x17) x (17x5)))))))))
# ...

def cmm():
  global sizes, C, P
  print(f'{sizes=}')
  mc = len(sizes) - 1        # mc=matrix count. 행렬의 수 이다
  C = [[ 0 for _ in range(mc + 1) ] for _ in range(mc + 1) ]                  # C[s][e] 에는 s 부터 e 까지 곱할 때의 최소연산수를 담는다
  P = [[ 0 for _ in range(mc + 1) ] for _ in range(mc + 1) ]
                 # P[s][e] 에는 s 부터 e 까지 곱할 때 마지막 곱셈을 할 인덱스를 담는다
  for sub in range(2, mc + 1): # 부분문제의 크기. 2부터 mc 까지 진행한다
    for s in range(1, mc - sub +2): # 부분문제가 시작되는 위치
      e = s + sub - 1            # 부분문제가 끝나는 위치
      C[s][e] = float('inf')            # s부터 e까지의 초기값을 넣고
      for k in range(s, e):    # k 를 s 부터 e 까지 옮겨가면서 마지막 곱셈을 어디서 할지 비교한다
         temp = C[s][k] + C[k+1][e] + sizes[s-1]*sizes[k]*sizes[e]
         if C[s][e] > temp:
            C[s][e] = temp
            P[s][e] = k
  print(C[1][mc], result(1, mc)) # 최종적으로 1 부터 mc 까지 곱할 때의 결과를 출력한다


def result(s, e):
  global sizes, C, P
  if s == e:                               # 시작과 끝이 같다면 행렬의 곱셈이 아닌 행렬 1개의 크기
    return f'({sizes[s-1]}x{sizes[s]})'
  p = P[s][e]                              # 마지막 곱셈의 위치
  if p == 0: return ''          # 만약 여기 걸리면 버그이다. 이럴리가 없다
  a = result(s, p)    # s 부터 p 까지의 곱셈 문자열
  b = result(p+1, e)  # p+1 부터 e 까지의 곱셈 문자열
  return f'({a} x {b})'         # 두 결과끼리의 곱셈 형태로 리턴한다

for q in questions:
  sizes = q
  cmm()
